package it.unibo.javadyno.model.dyno.simulated.impl;

import java.util.Objects;

import it.unibo.javadyno.model.dyno.simulated.api.Engine;
import it.unibo.javadyno.model.dyno.simulated.api.TemperatureModel;
import it.unibo.javadyno.model.dyno.simulated.api.TorqueMap;
import it.unibo.javadyno.model.dyno.simulated.api.WeatherStation;

/**
 * Simple engine implementation with inertia, torque is generated by a TorqueMap.
 */
public class EngineImpl implements Engine {
    /** value in [kg * m^2]. */
    private final double inertia;
    /** value in [rad/s]. */
    private double omega;
    /** value between [0.0-1.0]. */
    private double throttle;
    private final TorqueMap map;
    private final WeatherStation weatherStation;
    private final TemperatureModel temperatureModel;

    /**
     * @param inertia value in [kg * m^2] [must be >0]
     * @param map torque map implementation [nonnull]
     * @param temperatureModel temperature model
     */
    public EngineImpl(final double inertia, final TorqueMap map, final TemperatureModel temperatureModel, WeatherStation weatherStation) {
        if (inertia <= 0) {
            throw new IllegalArgumentException("Inertia must be > 0");
        }
        this.inertia = inertia;
        this.map = Objects.requireNonNull(map, "TorqueMap required");
        this.temperatureModel = Objects.requireNonNull(temperatureModel , "TemperatureModel required");
        this.weatherStation = weatherStation;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setThrottle(final double throttle) {
        if (throttle < 0.0 || throttle > 1.0) {
            throw new IllegalArgumentException("throttle must be between 0.0 and 1.0");
        }
        this.throttle = throttle;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void update(final double loadTorque, final double deltaTime) {
        final double generatedTorque = map.getTorque(throttle, omega);
        final double netTorque = generatedTorque - loadTorque;
        omega = omega + (netTorque / inertia) * deltaTime;
        if (omega < 0) {
            omega = 0;
        }
        double power = generatedTorque * omega;
        temperatureModel.update(generatedTorque, this.weatherStation.getTemperature(), deltaTime);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double getAngularVelocity() {
        return omega;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double getGeneratedTorque() {
        return map.getTorque(throttle, omega);

    }

    /**
     * method used only to set angular velocity during shift of gears.
     */
    @Override
    public void setAngularVelocity(double newEngineOmega) {
        if (omega < 0) {
            throw new IllegalArgumentException("omega >= 0");
        }
        this.omega = newEngineOmega;
    }

    @Override
    public double getEngineTemperature() {
       return this.temperatureModel.getTemperature();
    }
}
